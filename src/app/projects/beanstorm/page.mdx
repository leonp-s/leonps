import { YouTube } from "@/components/youtube";

_This post is under construction\*_

# Beanstorm

Espresso machine conversion incorporating pressure and temperature control via a
native IOS app over BLE. Realtime control in C++, native IOS app in
Swift/SwiftUI.

---

<YouTube id="lXTTcRKk1ds" />

## Introduction

### The Goal

For a while now, a number of existing and new espresso machines have been
offering features to enable precise control of pressure/flow, temperature,
profiles and graph; in real-time, shot characteristics. These features are
increasingly becoming desired and expected in the `specialty` coffee scene. The
Decent DE1, Meticulous and Gaggiuino have all served as significant inspiration
to the project. All of which facilitate pressure profiles, real-time graphing,
and temperature control.

### Starting Point

The starting point for the project is an unmodified Rancillio Silvia from 2012,
a clean slate to work from. The Rancillio Silvia is essentially a glorified
kettle, and that's why it's great. All the mechanical components to build a
great, capable espresso machine, without the software. The Silvia has no digital
control electronics, using thermal fuses for temperature control and a switch
wired directly to the vibratory pump to get the shot started. Vibratory pumps
are really effective for the size, they are also quite cheap but tend to be
quite loud. Both the Decent DE1 and Gaggiuino projects achieve pressure control
using vibratory pumps. For the Gaggiuino an in-line pressure transducer is used
to create the pressure control loop.

## Mechanics

In order to achieve a much quieter sound when the machine is pulling a shot, the
vibratory pump has been switched out for the Fluid OTech GA072. This is a DC
rotary vane pump that is used in lager, commercial, multi group-head espresso
machines and really has no place in a home machine like the Silvia.
Nevertheless, I managed to pick one up on eBay for about Â£80.00, and so I
thought I would give it a shot. This introduced a number of challenges, both
from an electronics standpoint (i.e. how can I power and control a 24V DC motor
in a small UK mains powered espresso machine) and also from a plumbing
perspective. These pumps are powerful, providing a flow-rate far too high for
conventional espresso.

<div className="grid grid-cols-2 gap-4 place-content-center items-center">
  <figure>
    <img
      src="/projects/beanstorm/pump_compare.jpg"
      alt="ULKA EP5 vs Fluid OTech GA072"
    />
    <figcaption>ULKA EP5 vs Fluid OTech GA072.</figcaption>
  </figure>
  <figure>
    <img src="/projects/beanstorm/pump_in_place.png" alt="Pump in place" />
    <figcaption>Pump in place within the machine.</figcaption>
  </figure>
</div>

To overcome the issue of flow rate, a bypass circuit is needed to essentially
drop the flow rate such that you have control for a range of RPMs. I found these
two threads super useful and explain in more detail the problems with
controlling flow/pressure with rotary vane pumps,
[convert-to-rotary-pump](https://www.home-barista.com/repairs/convert-to-rotary-pump-stepper-motor-t87534-20.html),
[pressure-profiling-with-fluid-o-tech](https://www.home-barista.com/espresso-machines/pressure-profiling-with-fluid-o-tech-tmfr-pump-or-wholesale-copying-greg-scaces-ideas-t12179.html).

These threads suggested drilling the regulator valve in the pump to create the
bypass (this sounded scary and I don't have access to a milling machine to get
through the steel valve). However, I have used an external bypass circuit across
the inlet and outlet of the pump with a variable needle valve in between that
allows me to tune the flow rate to the effective RPM range of the pump. I havexw
manually tunes the machine using the valve, however I would consider graphing
pressure against pump RPM with a blanking disk in place to tune this more
accurately.

## Electronics

Please do not rely on any of this build information, dealing with mains power
can be very dangerous, this post is in no way intended as advice.

This espresso mod removes entirely all original wiring of the machine to build a
new custom harness incorporating a hefty 240VAC - 24VDC converter, DC motor
speed controller, 40A SSR for temperature control of the boiler and mechanical
relay for switching the 3-way-valve in the group head. Alongside this, the
machine is controlled with an ESP32 S3 microcontroller an inline pressure
transducer (for pressure control) and thermocouple, connected to the boiler (for
temperature control).

<div className="flex gap-4 justify-center">
  <figure>
    <img
      src="/projects/beanstorm/ga072_current.png"
      alt="GA072 Pressure vs Flow vs Current"
      className="w-[360px]"
    />
    <figcaption>GA072 Pressure vs Flow vs Current.</figcaption>
  </figure>
</div>

- Motor power supply
- Motor speed controller
- SSR
- ESP32 S3
- Temperature sensor
- Pressure sensor

<div className="flex gap-4 justify-center">
  <figure>
    <img
      src="/projects/beanstorm/beanstorm_electronics.png"
      alt="New control electronics."
      className="w-[280px] -rotate-90"
    />
    <figcaption>New control electronics.</figcaption>
  </figure>
</div>

# Software -- NEEDS PROOF READING...

Beanstorm comprises two projects, the 'OS' and App. Beanstorm OS is written in
C++, running on the ESP32 S3 and is responsible for controlling the machine,
core tasks: taking sensor readings, switching the heating element, managing the
pump, opening the three-way solenoid valve, exposing values and offering an API
to interact with the machine via BLE, saving and executing pressure profiles.
The app is native IOS, written in Swift UI and interfaces with the machine via
BLE and Protobuf, the app can start shots, graph pressure and temperature
readings in realtime, design, save and modify profiles via an intuitive curve
editor, transfer profiles over to the machine and update different machine
settings.

## OS

TLDR:

- Architecture

  - Free RTOS (Threading)
  - Event Bridge

- Control logic
- Peripherals
- Controlling Temp
- Programs

- BLE / NimBLE
- Protobuf
- Interpreting Profiles

Beanstorm OS makes use of Free RTOS largely to separate concerns between
communications via BLE and the actual control of the machine. On startup, the
BLE service responsible for providing the API to interact with the app via BLE
is pinned to a separate core to the control logic. Communications are then made
via immutable, thread safe queues. The event bridge, responsible for sending
commands from the BLE service to the control service, and the notification
queue, which the control service can use to notify the BLE Service of changes
for example a shot starting (via a physical switch on the machine) or sensor
readings. The thinking behind this architecture was largely to separate the
interface for how the machine is communicated with vs how the machine is being
run. Take for example, the ESP32 supports WIFI so possibly at some point in
time, it would be good to support a user interface running using web
technologies, or possibly an embedded screen. On reflection, I could/should?
have used the event bridge for the switches on the machine.

The control side of the 'OS' has a few main responsibilities, reading and
interacting with different physical peripherals, running different programs
(modes), maintaining some form of machine state, controlling temperature and
executing pressure profiles. Peripherals are structured such that only a simple
API is provided to the caller (without the need to understand the underlying
mechanism), for example the temperature sensor provides a `ReadTemperature` call
returning the current temperature. I found this structure particularly helped
simplify the more complicated control logic in profiles. Temperature control is
achieved using PID, switching the SSR of the boiler with windowing. Similarly,
pressure control is achieved with PID, however this is controlling a variable
speed motor in the pump, with a relationship between RPM and pressure (this was
much more sensitive in tuning, and is much more susceptible to oscillations).
The control logic provides a loop that performs common tasks for example, sensor
readings, health check, probing the event bridge. However, the state is built
using a state machine, with different programs that can be entered and exited
and hook into the common loop. The idea behind this was in order to provide a
number of different modes, idle, brewing, steaming (needs to get hotter for
steaming milk and not run the pump), cleaning cycles and provide logical
separation between how each of these behave.

## App

- Swift UI
- Brew Graph
- Swift UI Charts
- Performance Issues
- Canvas Drawing
- Brew Profiles
- Saving / Loading
- Profile Editor
- Swift Data
- BLE
- Connecting Devices
- Managing Connection State
- Characteristics (Temp, Pressure, ...)
- Transferring Profiles
- Protobuf
